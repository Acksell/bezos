package ddbgen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	// bezosModule is the module path of the bezos library.
	// Sub-package imports in the sidecar template are constructed from this.
	bezosModule = "github.com/acksell/bezos"

	valPkg = bezosModule + "/dynamodb/index/val"
)

// GenerateOptions configures code generation behavior.
type GenerateOptions struct {
	// Dir is the directory containing the user's package
	Dir string
	// Output is the output file name for generated Go code
	Output string
	// NoSchema disables schema/ subdirectory generation
	NoSchema bool
}

// RunGenerate discovers PrimaryIndex definitions and generates code via
// a compile-and-execute sidecar program.
func RunGenerate(opts GenerateOptions) error {
	if opts.Dir == "" {
		opts.Dir = "."
	}
	if opts.Output == "" {
		opts.Output = "index_gen.go"
	}

	// Phase 1: Minimal type-checking to discover index variables and entity metadata
	result, err := Discover(opts.Dir)
	if err != nil {
		return fmt.Errorf("discovering indexes: %w", err)
	}

	if len(result.Indexes) == 0 {
		fmt.Fprintf(os.Stderr, "ddb gen: no index.PrimaryIndex definitions found in %s\n", opts.Dir)
		return nil
	}

	// Phase 2: Generate and run the sidecar program
	return runSidecar(result, opts)
}

func runSidecar(result *DiscoverResult, opts GenerateOptions) error {
	absDir, err := filepath.Abs(opts.Dir)
	if err != nil {
		return fmt.Errorf("resolving directory: %w", err)
	}

	outputPath := opts.Output
	if opts.Dir != "." {
		outputPath = filepath.Join(opts.Dir, opts.Output)
	}
	absOutput, err := filepath.Abs(outputPath)
	if err != nil {
		return fmt.Errorf("resolving output path: %w", err)
	}

	schemaDir := ""
	if !opts.NoSchema {
		schemaDir = filepath.Join(absDir, "schema")
	}

	// Find module root for replace directive and val import
	modRoot, _, err := findModuleRoot(absDir)
	if err != nil {
		return fmt.Errorf("finding module root: %w", err)
	}

	// Generate accessor file in the user's package so the sidecar can access unexported vars
	accessorPath := filepath.Join(absDir, "ddbgen_accessors.go")
	if err := generateAccessors(result, accessorPath); err != nil {
		return fmt.Errorf("generating accessors: %w", err)
	}
	defer os.Remove(accessorPath) // Clean up after sidecar runs

	// Generate the sidecar main.go source
	sidecarSrc, err := generateSidecarSource(result, absOutput, schemaDir)
	if err != nil {
		return fmt.Errorf("generating sidecar source: %w", err)
	}

	// Write sidecar into a temp subdirectory of the module root so it inherits
	// the user's go.mod â€” no separate go.mod, no go mod tidy, no downloads.
	tmpDir, err := os.MkdirTemp(modRoot, ".ddbgen-sidecar-*")
	if err != nil {
		return fmt.Errorf("creating temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	mainPath := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(mainPath, sidecarSrc, 0644); err != nil {
		return fmt.Errorf("writing sidecar main.go: %w", err)
	}

	// Build and run the sidecar from within the module root
	cmd := exec.Command("go", "run", mainPath)
	cmd.Dir = modRoot
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("sidecar execution failed: %w", err)
	}

	return nil
}

// findModuleRoot walks up from dir to find go.mod and returns (root dir, module path).
func findModuleRoot(dir string) (string, string, error) {
	current := dir
	for {
		goModPath := filepath.Join(current, "go.mod")
		data, err := os.ReadFile(goModPath)
		if err == nil {
			modPath := extractModulePath(string(data))
			if modPath == "" {
				return "", "", fmt.Errorf("could not parse module path from %s", goModPath)
			}
			return current, modPath, nil
		}
		parent := filepath.Dir(current)
		if parent == current {
			return "", "", fmt.Errorf("no go.mod found in %s or any parent directory", dir)
		}
		current = parent
	}
}

func extractModulePath(goModContent string) string {
	for _, line := range strings.Split(goModContent, "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module "))
		}
	}
	return ""
}

// generateAccessors writes a small Go file into the user's package that exports
// accessor functions for unexported PrimaryIndex variables. This allows the sidecar
// to import and call them at runtime.
func generateAccessors(result *DiscoverResult, outputPath string) error {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by ddbgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", result.PackageName)
	fmt.Fprintf(&buf, "import \"github.com/acksell/bezos/dynamodb/index\"\n\n")

	for _, idx := range result.Indexes {
		funcName := accessorFuncName(idx.VarName)
		fmt.Fprintf(&buf, "func %s() index.PrimaryIndex[%s] { return %s }\n",
			funcName, idx.EntityType, idx.VarName)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting accessor file: %w\n%s", err, buf.String())
	}

	return os.WriteFile(outputPath, formatted, 0644)
}

// accessorFuncName returns the exported accessor function name for a variable.
// e.g., "userIndex" -> "DdbgenGet_userIndex"
func accessorFuncName(varName string) string {
	return "DdbgenGet_" + varName
}

func generateSidecarSource(result *DiscoverResult, outputPath, schemaDir string) ([]byte, error) {
	tmpl, err := template.New("sidecar").Delims("[[", "]]").Funcs(template.FuncMap{
		"accessorFunc": accessorFuncName,
	}).Parse(sidecarTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing sidecar template: %w", err)
	}

	data := sidecarTemplateData{
		UserPackagePath: result.PackagePath,
		UserPackageName: result.PackageName,
		ValPkg:          valPkg,
		OutputPath:      outputPath,
		SchemaDir:       schemaDir,
		Indexes:         result.Indexes,
		EntityFields:    result.EntityFields,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("executing sidecar template: %w", err)
	}

	return buf.Bytes(), nil
}

type sidecarTemplateData struct {
	UserPackagePath string
	UserPackageName string
	ValPkg          string
	OutputPath      string
	SchemaDir       string
	Indexes         []IndexVar
	EntityFields    map[string][]FieldInfo
}

// sidecarTemplate is the Go source template for the self-contained sidecar program.
// It imports the user's package to access PrimaryIndex variables at runtime,
// then generates index_gen.go and schema files.
var sidecarTemplate = `// Code generated by ddbgen. DO NOT EDIT.
// Temporary sidecar program for code generation.
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	userpkg "[[.UserPackagePath]]"
	"[[.ValPkg]]"

	"gopkg.in/yaml.v3"
)

// =============================================================================
// Entity metadata (from Phase 1 type-checking)
// =============================================================================

type fieldInfo struct {
	Name string
	Tag  string
	Type string
}

type indexMeta struct {
	VarName     string
	EntityType  string
	IsVersioned bool
	Fields      []fieldInfo
}

var indexMetadata = []indexMeta{
[[- range .Indexes]]
	{
		VarName:     "[[.VarName]]",
		EntityType:  "[[.EntityType]]",
		IsVersioned: [[.IsVersioned]],
		Fields: []fieldInfo{
		[[- range (index $.EntityFields .EntityType)]]
			{Name: "[[.Name]]", Tag: "[[.Tag]]", Type: "[[.Type]]"},
		[[- end]]
		},
	},
[[- end]]
}

// =============================================================================
// Runtime index extraction
// =============================================================================

type indexInfo struct {
	VarName      string
	EntityType   string
	TableName    string
	PKDefName    string
	SKDefName    string
	PartitionKey keyPattern
	SortKey      keyPattern
	GSIs         []gsiInfo
	IsVersioned  bool
	Fields       []fieldInfo
}

type keyPattern struct {
	Pattern string
	Kind    string // "S", "N", "B"
}

type gsiInfo struct {
	Name      string
	Index     int
	PKDef     string
	PKPattern keyPattern
	SKDef     string
	SKPattern keyPattern
}

func extractValDef(vd val.ValDef) keyPattern {
	if vd.Format != nil {
		return keyPattern{Pattern: vd.Format.Raw, Kind: string(vd.Format.Kind)}
	}
	if vd.Const != nil {
		kind := string(vd.Const.Kind())
		switch kind {
		case "B":
			if b, ok := vd.Const.Value().([]byte); ok {
				return keyPattern{Pattern: base64.StdEncoding.EncodeToString(b), Kind: kind}
			}
		}
		return keyPattern{Pattern: fmt.Sprintf("%v", vd.Const.Value()), Kind: kind}
	}
	if vd.FromField != "" {
		return keyPattern{Pattern: "{" + vd.FromField + "}", Kind: "S"}
	}
	return keyPattern{}
}

func extractValDefPtr(vd *val.ValDef) keyPattern {
	if vd == nil {
		return keyPattern{}
	}
	return extractValDef(*vd)
}

func extractIndexes() []indexInfo {
	var indexes []indexInfo
[[range .Indexes]]
	{
		idx := userpkg.[[accessorFunc .VarName]]()
		meta := findMeta("[[.VarName]]")
		info := indexInfo{
			VarName:      meta.VarName,
			EntityType:   meta.EntityType,
			IsVersioned:  meta.IsVersioned,
			Fields:       meta.Fields,
			TableName:    idx.Table.Name,
			PKDefName:    idx.Table.KeyDefinitions.PartitionKey.Name,
			SKDefName:    idx.Table.KeyDefinitions.SortKey.Name,
			PartitionKey: extractValDef(idx.PartitionKey),
		}
		if idx.SortKey != nil {
			info.SortKey = extractValDefPtr(idx.SortKey)
		}
		for i, sec := range idx.Secondary {
			gsi := gsiInfo{
				Name:      sec.GSI.Name,
				Index:     i,
				PKDef:     sec.GSI.KeyDefinitions.PartitionKey.Name,
				PKPattern: extractValDef(sec.Partition),
				SKDef:     sec.GSI.KeyDefinitions.SortKey.Name,
			}
			if sec.Sort != nil {
				gsi.SKPattern = extractValDefPtr(sec.Sort)
			}
			info.GSIs = append(info.GSIs, gsi)
		}
		indexes = append(indexes, info)
	}
[[end]]
	return indexes
}

func findMeta(varName string) indexMeta {
	for _, m := range indexMetadata {
		if m.VarName == varName {
			return m
		}
	}
	panic("no metadata for " + varName)
}

// =============================================================================
// Main
// =============================================================================

func main() {
	indexes := extractIndexes()

	code, err := generateCode("[[.UserPackageName]]", indexes)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ddb gen: generating code: %v\n", err)
		os.Exit(1)
	}

	outputPath := ` + "`[[.OutputPath]]`" + `
	if err := os.WriteFile(outputPath, code, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "ddb gen: writing output: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("ddb gen: generated %s (%d indexes)\n", outputPath, len(indexes))
[[if .SchemaDir]]
	schemaDir := ` + "`[[.SchemaDir]]`" + `
	if err := os.MkdirAll(schemaDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "ddb gen: creating schema directory: %v\n", err)
		os.Exit(1)
	}
	if err := generateSchemaFiles(schemaDir, indexes); err != nil {
		fmt.Fprintf(os.Stderr, "ddb gen: generating schema: %v\n", err)
		os.Exit(1)
	}
[[end]]
}

// =============================================================================
// Key pattern parsing
// =============================================================================

type fmtSpec struct {
	Raw   string
	Kind  string
	Parts []specPart
}

type specPart struct {
	IsLiteral  bool
	Value      string
	Formats    []string
	PrintfSpec string
}

func (p specPart) format() string {
	if len(p.Formats) == 0 {
		return ""
	}
	return p.Formats[len(p.Formats)-1]
}

func (p specPart) hasModifier(mod string) bool {
	for _, f := range p.Formats {
		if f == mod {
			return true
		}
	}
	return false
}

func (p specPart) paramName() string {
	parts := strings.Split(p.Value, ".")
	return parts[len(parts)-1]
}

var fieldRefRegex = regexp.MustCompile(` + "`" + `\{([^}]*)\}` + "`" + `)

func parseFmtSpec(raw, kind string) (*fmtSpec, error) {
	if raw == "" {
		return nil, fmt.Errorf("pattern cannot be empty")
	}
	s := &fmtSpec{Raw: raw, Kind: kind}
	matches := fieldRefRegex.FindAllStringSubmatchIndex(raw, -1)
	if len(matches) == 0 {
		s.Parts = []specPart{{IsLiteral: true, Value: raw}}
		return s, nil
	}
	lastEnd := 0
	for _, match := range matches {
		start, end := match[0], match[1]
		fieldStart, fieldEnd := match[2], match[3]
		if start > lastEnd {
			s.Parts = append(s.Parts, specPart{IsLiteral: true, Value: raw[lastEnd:start]})
		}
		fullRef := raw[fieldStart:fieldEnd]
		if fullRef == "" {
			return nil, fmt.Errorf("empty field reference at position %d", start)
		}
		fieldPath, formats, printfSpec := parseFieldRef(fullRef)
		s.Parts = append(s.Parts, specPart{
			IsLiteral:  false,
			Value:      fieldPath,
			Formats:    formats,
			PrintfSpec: printfSpec,
		})
		lastEnd = end
	}
	if lastEnd < len(raw) {
		s.Parts = append(s.Parts, specPart{IsLiteral: true, Value: raw[lastEnd:]})
	}
	return s, nil
}

func parseFieldRef(ref string) (fieldPath string, formats []string, printfSpec string) {
	parts := strings.Split(ref, ":")
	fieldPath = parts[0]
	if len(parts) == 1 {
		return
	}
	lastPart := parts[len(parts)-1]
	if strings.HasPrefix(lastPart, "%") {
		printfSpec = lastPart
		formats = parts[1 : len(parts)-1]
	} else {
		formats = parts[1:]
	}
	return
}

func (s fmtSpec) isConstant() bool {
	return len(s.Parts) == 1 && s.Parts[0].IsLiteral
}

func (s fmtSpec) literalPrefix() string {
	if len(s.Parts) > 0 && s.Parts[0].IsLiteral {
		return s.Parts[0].Value
	}
	return ""
}

func (s fmtSpec) fieldRefs() []specPart {
	var refs []specPart
	for _, part := range s.Parts {
		if !part.IsLiteral {
			refs = append(refs, part)
		}
	}
	return refs
}

// =============================================================================
// Type helpers
// =============================================================================

func isIntegerType(t string) bool {
	switch t {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return true
	}
	return false
}

func isSignedIntegerType(t string) bool {
	switch t {
	case "int", "int8", "int16", "int32", "int64":
		return true
	}
	return false
}

func isFloatType(t string) bool {
	return t == "float32" || t == "float64"
}

func isTimeType(t string) bool {
	return t == "time.Time" || t == "Time"
}

func hasPadding(spec string) bool {
	return strings.HasPrefix(spec, "%0") && len(spec) > 2
}

func goParamType(fieldType string) string {
	if fieldType == "string" {
		return "string"
	}
	if isTimeType(fieldType) {
		return "time.Time"
	}
	return fieldType
}

// =============================================================================
// Conversion expression generation
// =============================================================================

type conversionResult struct {
	Expr        string
	UsesFmt     bool
	UsesStrconv bool
	UsesTime    bool
}

func generateConversionExpr(p specPart, fieldExpr string, fieldType string) (conversionResult, error) {
	if fieldType == "string" {
		if p.PrintfSpec != "" {
			return conversionResult{Expr: fmt.Sprintf("fmt.Sprintf(%q, %s)", p.PrintfSpec, fieldExpr), UsesFmt: true}, nil
		}
		return conversionResult{Expr: fieldExpr}, nil
	}
	if isIntegerType(fieldType) {
		if p.PrintfSpec != "" {
			return conversionResult{Expr: fmt.Sprintf("fmt.Sprintf(%q, %s)", p.PrintfSpec, fieldExpr), UsesFmt: true}, nil
		}
		if isSignedIntegerType(fieldType) {
			if fieldType == "int64" {
				return conversionResult{Expr: fmt.Sprintf("strconv.FormatInt(%s, 10)", fieldExpr), UsesStrconv: true}, nil
			}
			return conversionResult{Expr: fmt.Sprintf("strconv.FormatInt(int64(%s), 10)", fieldExpr), UsesStrconv: true}, nil
		}
		if fieldType == "uint64" {
			return conversionResult{Expr: fmt.Sprintf("strconv.FormatUint(%s, 10)", fieldExpr), UsesStrconv: true}, nil
		}
		return conversionResult{Expr: fmt.Sprintf("strconv.FormatUint(uint64(%s), 10)", fieldExpr), UsesStrconv: true}, nil
	}
	if isFloatType(fieldType) {
		format := p.format()
		if p.PrintfSpec == "" && format == "" {
			return conversionResult{}, fmt.Errorf("float type %s requires explicit format", fieldType)
		}
		spec := p.PrintfSpec
		if spec == "" {
			spec = format
		}
		return conversionResult{Expr: fmt.Sprintf("fmt.Sprintf(%q, %s)", spec, fieldExpr), UsesFmt: true}, nil
	}
	if isTimeType(fieldType) {
		format := p.format()
		if format == "" {
			return conversionResult{}, fmt.Errorf("time.Time field requires explicit format")
		}
		timeExpr := fieldExpr
		if p.hasModifier("utc") {
			timeExpr = fmt.Sprintf("%s.UTC()", fieldExpr)
		}
		switch format {
		case "unix":
			if p.PrintfSpec != "" {
				return conversionResult{Expr: fmt.Sprintf("fmt.Sprintf(%q, %s.Unix())", p.PrintfSpec, timeExpr), UsesFmt: true}, nil
			}
			return conversionResult{Expr: fmt.Sprintf("strconv.FormatInt(%s.Unix(), 10)", timeExpr), UsesStrconv: true}, nil
		case "unixmilli":
			if p.PrintfSpec != "" {
				return conversionResult{Expr: fmt.Sprintf("fmt.Sprintf(%q, %s.UnixMilli())", p.PrintfSpec, timeExpr), UsesFmt: true}, nil
			}
			return conversionResult{Expr: fmt.Sprintf("strconv.FormatInt(%s.UnixMilli(), 10)", timeExpr), UsesStrconv: true}, nil
		case "unixnano":
			if p.PrintfSpec != "" {
				return conversionResult{Expr: fmt.Sprintf("fmt.Sprintf(%q, %s.UnixNano())", p.PrintfSpec, timeExpr), UsesFmt: true}, nil
			}
			return conversionResult{Expr: fmt.Sprintf("strconv.FormatInt(%s.UnixNano(), 10)", timeExpr), UsesStrconv: true}, nil
		case "rfc3339":
			return conversionResult{Expr: fmt.Sprintf("%s.Format(time.RFC3339)", timeExpr), UsesTime: true}, nil
		case "rfc3339fixed":
			return conversionResult{Expr: fmt.Sprintf("%s.Format(%q)", timeExpr, "2006-01-02T15:04:05.000000000Z07:00")}, nil
		case "rfc3339nano":
			return conversionResult{Expr: fmt.Sprintf("%s.Format(time.RFC3339Nano)", timeExpr), UsesTime: true}, nil
		case "utc":
			return conversionResult{}, fmt.Errorf("time.Time field with :utc modifier requires a format")
		default:
			return conversionResult{Expr: fmt.Sprintf("%s.Format(%q)", timeExpr, format)}, nil
		}
	}
	return conversionResult{Expr: fmt.Sprintf("fmt.Sprintf(\"%%v\", %s)", fieldExpr), UsesFmt: true}, nil
}

func sortKeyWarning(p specPart, fieldType string, entityType string) string {
	if isIntegerType(fieldType) && !hasPadding(p.PrintfSpec) {
		return fmt.Sprintf("warning: %s sort key uses %s without padding format.\n"+
			"  String comparison treats \"9\" > \"10\". For correct ordering either:\n"+
			"  - Use DynamoDB Number type for the sort key\n"+
			"  - Add zero-padding: {field:%%020d}\n", entityType, fieldType)
	}
	if isFloatType(fieldType) && !hasPadding(p.PrintfSpec) {
		spec := p.PrintfSpec
		if spec == "" {
			spec = p.format()
		}
		return fmt.Sprintf("warning: %s sort key uses %s format %q without total width padding.\n"+
			"  For correct string sorting, specify total width: {field:%%020.2f}\n", entityType, fieldType, spec)
	}
	format := p.format()
	if isTimeType(fieldType) {
		switch format {
		case "unix":
			if !hasPadding(p.PrintfSpec) {
				return fmt.Sprintf("warning: %s sort key uses \"unix\" timestamp without padding.\n"+
					"  Unix timestamps change digit count (9 digits before 2001-09-09, 10 after).\n"+
					"  For correct string sorting, add padding: {field:unix:%%011d}\n", entityType)
			}
		case "unixmilli":
			if !hasPadding(p.PrintfSpec) {
				return fmt.Sprintf("warning: %s sort key uses \"unixmilli\" timestamp without padding.\n"+
					"  Unix millisecond timestamps change digit count (12 digits before 2001-09-09, 13 after).\n"+
					"  For correct string sorting, add padding: {field:unixmilli:%%014d}\n", entityType)
			}
		case "unixnano":
			if !hasPadding(p.PrintfSpec) {
				return fmt.Sprintf("warning: %s sort key uses \"unixnano\" timestamp without padding.\n"+
					"  Unix nanosecond timestamps change digit count (18 digits before 2001-09-09, 19 after).\n"+
					"  For correct string sorting, add padding: {field:unixnano:%%020d}\n", entityType)
			}
		case "rfc3339":
			return fmt.Sprintf("warning: %s sort key uses \"rfc3339\" time format.\n"+
				"  RFC3339 has variable-width timezone offsets (+00:00 vs Z vs +05:30), making\n"+
				"  string comparison unreliable for ordering across timezones.\n"+
				"  For correct string ordering, prefer:\n"+
				"  - unix, unixmilli, or unixnano with padding (numeric, timezone-independent)\n"+
				"  - {field:utc:rfc3339fixed} to normalize to UTC with constant length\n", entityType)
		case "rfc3339fixed":
			if !p.hasModifier("utc") {
				return fmt.Sprintf("warning: %s sort key uses \"rfc3339fixed\" without :utc modifier.\n"+
					"  While rfc3339fixed has constant length, different timezone offsets still\n"+
					"  cause incorrect string ordering (e.g., \"...+05:00\" > \"...Z\").\n"+
					"  For correct ordering, either:\n"+
					"  - Use {field:utc:rfc3339fixed} to normalize to UTC\n"+
					"  - Use unix/unixmilli/unixnano with padding (timezone-independent)\n", entityType)
			}
		case "rfc3339nano":
			return fmt.Sprintf("warning: %s sort key uses \"rfc3339nano\" time format.\n"+
				"  RFC3339Nano has variable length (trailing zeros stripped) and timezone issues.\n"+
				"  For correct string ordering, prefer:\n"+
				"  - unix, unixmilli, or unixnano with padding\n"+
				"  - {field:utc:rfc3339fixed} (constant length, UTC-normalized)\n", entityType)
		}
	}
	return ""
}

// =============================================================================
// Index data building
// =============================================================================

type indexData struct {
	Name         string
	IndexVarName string
	EntityType   string
	PartitionKey keyData
	SortKey      *keyData
	HasSortKey   bool
	GSIs         []gsiData
	IsVersioned  bool
}

func (d indexData) HasEntity() bool { return d.EntityType != "" }

type keyData struct {
	Params           []paramData
	FormatExpr       string
	EntityFormatExpr string
	IsConstant       bool
	LiteralPrefix    string
	FieldRefNames    []string
	UsesFmt          bool
	UsesStrconv      bool
	UsesTime         bool
}

type paramData struct {
	Name       string
	Type       string
	FieldType  string
	Formats    []string
	PrintfSpec string
}

type gsiData struct {
	Name         string
	Index        int
	PartitionKey keyData
	SortKey      *keyData
	HasSortKey   bool
}

func buildIndexData(idx indexInfo) (indexData, error) {
	tagMap := make(map[string]fieldInfo)
	for _, f := range idx.Fields {
		tagMap[f.Tag] = f
	}

	pkData, err := buildKeyData(idx.PartitionKey, tagMap, false, idx.EntityType)
	if err != nil {
		return indexData{}, fmt.Errorf("partition key: %w", err)
	}

	data := indexData{
		Name:         idx.EntityType,
		IndexVarName: idx.VarName,
		EntityType:   idx.EntityType,
		PartitionKey: pkData,
		IsVersioned:  idx.IsVersioned,
	}

	if idx.SortKey.Pattern != "" {
		skData, err := buildKeyData(idx.SortKey, tagMap, true, idx.EntityType)
		if err != nil {
			return indexData{}, fmt.Errorf("sort key: %w", err)
		}
		data.HasSortKey = true
		data.SortKey = &skData
	}

	for _, gsi := range idx.GSIs {
		gd, err := buildGSIData(gsi, tagMap, idx.EntityType)
		if err != nil {
			return indexData{}, fmt.Errorf("GSI %s: %w", gsi.Name, err)
		}
		data.GSIs = append(data.GSIs, gd)
	}

	return data, nil
}

func buildGSIData(gsi gsiInfo, tagMap map[string]fieldInfo, entityType string) (gsiData, error) {
	pkData, err := buildKeyData(gsi.PKPattern, tagMap, false, entityType)
	if err != nil {
		return gsiData{}, fmt.Errorf("partition key: %w", err)
	}

	data := gsiData{
		Name:         gsi.Name,
		Index:        gsi.Index,
		PartitionKey: pkData,
	}

	if gsi.SKPattern.Pattern != "" {
		skData, err := buildKeyData(gsi.SKPattern, tagMap, true, entityType)
		if err != nil {
			return gsiData{}, fmt.Errorf("sort key: %w", err)
		}
		data.HasSortKey = true
		data.SortKey = &skData
	}

	return data, nil
}

func buildKeyData(kp keyPattern, tagMap map[string]fieldInfo, isSortKey bool, entityType string) (keyData, error) {
	spec, err := parseFmtSpec(kp.Pattern, kp.Kind)
	if err != nil {
		return keyData{}, fmt.Errorf("invalid pattern %q: %w", kp.Pattern, err)
	}

	if spec.isConstant() {
		formatExpr := fmt.Sprintf("%q", kp.Pattern)
		if kp.Kind == "B" {
			decoded, err := base64.StdEncoding.DecodeString(kp.Pattern)
			if err != nil {
				return keyData{}, fmt.Errorf("invalid base64 for bytes key: %w", err)
			}
			formatExpr = formatByteLiteral(decoded)
		}
		return keyData{
			FormatExpr:       formatExpr,
			EntityFormatExpr: formatExpr,
			IsConstant:       true,
			LiteralPrefix:    kp.Pattern,
		}, nil
	}

	var params []paramData
	var formatParts, entityFormatParts []string
	var fieldRefNames []string
	usesStrconv, usesTime, usesFmt := false, false, false
	literalPrefix := spec.literalPrefix()

	for _, part := range spec.Parts {
		if part.IsLiteral {
			formatParts = append(formatParts, fmt.Sprintf("%q", part.Value))
			entityFormatParts = append(entityFormatParts, fmt.Sprintf("%q", part.Value))
			continue
		}
		field, ok := tagMap[part.Value]
		if !ok {
			return keyData{}, fmt.Errorf("no struct field found with tag %q", part.Value)
		}
		pName := part.paramName()
		pType := goParamType(field.Type)
		if pType == "time.Time" {
			usesTime = true
		}
		params = append(params, paramData{
			Name: pName, Type: pType, FieldType: field.Type,
			Formats: part.Formats, PrintfSpec: part.PrintfSpec,
		})
		if isSortKey {
			if w := sortKeyWarning(part, field.Type, entityType); w != "" {
				fmt.Fprint(os.Stderr, w)
			}
		}
		paramResult, err := generateConversionExpr(part, pName, field.Type)
		if err != nil {
			return keyData{}, fmt.Errorf("field %q: %w", part.Value, err)
		}
		formatParts = append(formatParts, paramResult.Expr)
		fieldRefNames = append(fieldRefNames, pName)
		usesStrconv = usesStrconv || paramResult.UsesStrconv
		usesTime = usesTime || paramResult.UsesTime
		usesFmt = usesFmt || paramResult.UsesFmt

		entityResult, err := generateConversionExpr(part, "e."+field.Name, field.Type)
		if err != nil {
			return keyData{}, fmt.Errorf("field %q: %w", part.Value, err)
		}
		entityFormatParts = append(entityFormatParts, entityResult.Expr)
		usesStrconv = usesStrconv || entityResult.UsesStrconv
		usesTime = usesTime || entityResult.UsesTime
		usesFmt = usesFmt || entityResult.UsesFmt
	}

	return keyData{
		Params:           params,
		FormatExpr:       joinExprParts(formatParts),
		EntityFormatExpr: joinExprParts(entityFormatParts),
		LiteralPrefix:    literalPrefix,
		FieldRefNames:    fieldRefNames,
		UsesFmt:          usesFmt,
		UsesStrconv:      usesStrconv,
		UsesTime:         usesTime,
	}, nil
}

func joinExprParts(parts []string) string {
	if len(parts) == 0 {
		return ` + "`" + `""` + "`" + `
	}
	if len(parts) == 1 {
		return parts[0]
	}
	return strings.Join(parts, " + ")
}

func formatByteLiteral(data []byte) string {
	if len(data) == 0 {
		return "[]byte{}"
	}
	var parts []string
	for _, b := range data {
		parts = append(parts, fmt.Sprintf("0x%02x", b))
	}
	return "[]byte{" + strings.Join(parts, ", ") + "}"
}

func buildSKBoundExpr(kd keyData, suffix string) string {
	if len(kd.Params) == 0 {
		return kd.FormatExpr
	}
	if len(kd.Params) == 1 {
		p := kd.Params[0]
		paramName := p.Name + suffix
		sp := specPart{Value: p.Name, Formats: p.Formats, PrintfSpec: p.PrintfSpec}
		result, err := generateConversionExpr(sp, paramName, p.FieldType)
		if err != nil {
			return fmt.Sprintf("fmt.Sprintf(\"%%v\", %s)", paramName)
		}
		if kd.LiteralPrefix != "" {
			return fmt.Sprintf("%q + %s", kd.LiteralPrefix, result.Expr)
		}
		return result.Expr
	}
	var parts []string
	if kd.LiteralPrefix != "" {
		parts = append(parts, fmt.Sprintf("%q", kd.LiteralPrefix))
	}
	for _, p := range kd.Params {
		paramName := p.Name + suffix
		sp := specPart{Value: p.Name, Formats: p.Formats, PrintfSpec: p.PrintfSpec}
		result, err := generateConversionExpr(sp, paramName, p.FieldType)
		if err != nil {
			parts = append(parts, fmt.Sprintf("fmt.Sprintf(\"%%v\", %s)", paramName))
		} else {
			parts = append(parts, result.Expr)
		}
	}
	return strings.Join(parts, " + ")
}

// =============================================================================
// Template functions and code generation
// =============================================================================

func needsFmtImport(idx indexData) bool {
	if idx.PartitionKey.UsesFmt { return true }
	if idx.SortKey != nil && idx.SortKey.UsesFmt { return true }
	for _, gsi := range idx.GSIs {
		if gsi.PartitionKey.UsesFmt { return true }
		if gsi.SortKey != nil && gsi.SortKey.UsesFmt { return true }
	}
	return false
}

func needsStrconvImport(idx indexData) bool {
	if idx.PartitionKey.UsesStrconv { return true }
	if idx.SortKey != nil && idx.SortKey.UsesStrconv { return true }
	for _, gsi := range idx.GSIs {
		if gsi.PartitionKey.UsesStrconv { return true }
		if gsi.SortKey != nil && gsi.SortKey.UsesStrconv { return true }
	}
	return false
}

func needsTimeImport(idx indexData) bool {
	if idx.PartitionKey.UsesTime { return true }
	if idx.SortKey != nil && idx.SortKey.UsesTime { return true }
	for _, gsi := range idx.GSIs {
		if gsi.PartitionKey.UsesTime { return true }
		if gsi.SortKey != nil && gsi.SortKey.UsesTime { return true }
	}
	return false
}

var tmplFuncs = template.FuncMap{
	"allParams": func(idx indexData) string {
		var parts []string
		for _, p := range idx.PartitionKey.Params {
			parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
		}
		if idx.SortKey != nil {
			for _, p := range idx.SortKey.Params {
				parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
			}
		}
		return strings.Join(parts, ", ")
	},
	"allArgs": func(idx indexData) string {
		var args []string
		for _, p := range idx.PartitionKey.Params {
			args = append(args, p.Name)
		}
		if idx.SortKey != nil {
			for _, p := range idx.SortKey.Params {
				args = append(args, p.Name)
			}
		}
		return strings.Join(args, ", ")
	},
	"gsiAllParams": func(gsi gsiData) string {
		var parts []string
		for _, p := range gsi.PartitionKey.Params {
			parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
		}
		if gsi.SortKey != nil {
			for _, p := range gsi.SortKey.Params {
				parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
			}
		}
		return strings.Join(parts, ", ")
	},
	"gsiAllArgs": func(gsi gsiData) string {
		var args []string
		for _, p := range gsi.PartitionKey.Params {
			args = append(args, p.Name)
		}
		if gsi.SortKey != nil {
			for _, p := range gsi.SortKey.Params {
				args = append(args, p.Name)
			}
		}
		return strings.Join(args, ", ")
	},
	"pkParams": func(kd keyData) string {
		var parts []string
		for _, p := range kd.Params {
			parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
		}
		return strings.Join(parts, ", ")
	},
	"pkArgs": func(kd keyData) string {
		var args []string
		for _, p := range kd.Params {
			args = append(args, p.Name)
		}
		return strings.Join(args, ", ")
	},
	"skPrefix": func(kd keyData) string {
		if len(kd.FieldRefNames) == 1 {
			name := kd.FieldRefNames[0]
			if len(name) == 0 {
				return "SK"
			}
			return strings.ToUpper(name[:1]) + name[1:]
		}
		return "SK"
	},
	"skEqualsFormatExpr":  func(kd keyData) string { return kd.FormatExpr },
	"skBeginsWithExpr": func(kd keyData) string {
		if kd.LiteralPrefix != "" {
			return fmt.Sprintf("%q + prefix", kd.LiteralPrefix)
		}
		return "prefix"
	},
	"skBetweenStartExpr":    func(kd keyData) string { return buildSKBoundExpr(kd, "Start") },
	"skBetweenEndExpr":      func(kd keyData) string { return buildSKBoundExpr(kd, "End") },
	"skBoundExpr":           func(kd keyData) string { return buildSKBoundExpr(kd, "") },
	"skBeginsWithParams":    func(kd keyData) string { return "prefix string" },
	"skEqualsParams": func(kd keyData) string {
		var parts []string
		for _, p := range kd.Params {
			parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
		}
		return strings.Join(parts, ", ")
	},
	"skBetweenParams": func(kd keyData) string {
		var parts []string
		for _, p := range kd.Params {
			parts = append(parts, fmt.Sprintf("%sStart %s, %sEnd %s", p.Name, p.Type, p.Name, p.Type))
		}
		return strings.Join(parts, ", ")
	},
	"skSingleValueParams": func(kd keyData) string {
		var parts []string
		for _, p := range kd.Params {
			parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
		}
		return strings.Join(parts, ", ")
	},
}

func generateCode(packageName string, indexes []indexInfo) ([]byte, error) {
	var idxDataList []indexData
	needsFmt, needsStrconv, needsTime := false, false, false

	for _, idx := range indexes {
		data, err := buildIndexData(idx)
		if err != nil {
			return nil, fmt.Errorf("building data for %s: %w", idx.VarName, err)
		}
		idxDataList = append(idxDataList, data)
		if needsFmtImport(data) { needsFmt = true }
		if needsStrconvImport(data) { needsStrconv = true }
		if needsTimeImport(data) { needsTime = true }
	}

	imports := []string{
		` + "`" + `"github.com/acksell/bezos/dynamodb/ddbsdk"` + "`" + `,
		` + "`" + `"github.com/acksell/bezos/dynamodb/index"` + "`" + `,
		` + "`" + `"github.com/acksell/bezos/dynamodb/table"` + "`" + `,
	}
	if needsFmt {
		imports = append([]string{` + "`" + `"fmt"` + "`" + `}, imports...)
	}
	if needsStrconv {
		imports = append([]string{` + "`" + `"strconv"` + "`" + `}, imports...)
	}
	if needsTime {
		imports = append([]string{` + "`" + `"time"` + "`" + `}, imports...)
	}

	tmplData := struct {
		Package string
		Imports []string
		Indexes []indexData
	}{packageName, imports, idxDataList}

	tmpl, err := template.New("main").Funcs(tmplFuncs).Parse(codeTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, tmplData); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("formatting generated code: %w\n%s", err, buf.String())
	}
	return formatted, nil
}

const codeTemplate = ` + "`" + `// Code generated by ddbgen. DO NOT EDIT.

package {{.Package}}

import (
{{- range .Imports}}
	{{.}}
{{- end}}
)

{{range $idx := .Indexes}}
// =============================================================================
// {{$idx.Name}} Index Wrapper
// =============================================================================

// {{$idx.Name}}IndexUtil wraps the PrimaryIndex with strongly-typed methods.
type {{$idx.Name}}IndexUtil struct {
	*index.PrimaryIndex[{{$idx.EntityType}}]
}

// {{$idx.Name}}Index is the typed wrapper for {{$idx.Name}} operations.
var {{$idx.Name}}Index = {{$idx.Name}}IndexUtil{PrimaryIndex: &{{$idx.IndexVarName}}}

// PrimaryKey creates a primary key from explicit parameters.
func (idx {{$idx.Name}}IndexUtil) PrimaryKey({{allParams $idx}}) table.PrimaryKey {
	return table.PrimaryKey{
		Definition: idx.Table.KeyDefinitions,
		Values: table.PrimaryKeyValues{
			PartitionKey: {{$idx.PartitionKey.FormatExpr}},
			{{- if $idx.HasSortKey}}
			SortKey:      {{$idx.SortKey.FormatExpr}},
			{{- end}}
		},
	}
}
{{if $idx.HasEntity}}
// PrimaryKeyFrom creates the primary key from a {{$idx.EntityType}} entity.
func (idx {{$idx.Name}}IndexUtil) PrimaryKeyFrom(e *{{$idx.EntityType}}) table.PrimaryKey {
	return table.PrimaryKey{
		Definition: idx.Table.KeyDefinitions,
		Values: table.PrimaryKeyValues{
			PartitionKey: {{$idx.PartitionKey.EntityFormatExpr}},
			{{- if $idx.HasSortKey}}
			SortKey:      {{$idx.SortKey.EntityFormatExpr}},
			{{- end}}
		},
	}
}
{{if $idx.GSIs}}
// GSIKeysFrom creates all GSI keys from a {{$idx.EntityType}} entity.
func (idx {{$idx.Name}}IndexUtil) GSIKeysFrom(e *{{$idx.EntityType}}) []table.PrimaryKey {
	return []table.PrimaryKey{
		{{- range $gsi := $idx.GSIs}}
		{
			Definition: idx.Secondary[{{$gsi.Index}}].KeyDefinition(),
			Values: table.PrimaryKeyValues{
				PartitionKey: {{$gsi.PartitionKey.EntityFormatExpr}},
				{{- if $gsi.HasSortKey}}
				SortKey:      {{$gsi.SortKey.EntityFormatExpr}},
				{{- end}}
			},
		},
		{{- end}}
	}
}
{{end}}
// UnsafePut creates a Put operation without optimistic locking.
func (idx {{$idx.Name}}IndexUtil) UnsafePut(e *{{$idx.EntityType}}) *ddbsdk.Put {
	{{- if $idx.GSIs}}
	return ddbsdk.NewUnsafePut(idx.Table, idx.PrimaryKeyFrom(e), e).WithGSIKeys(idx.GSIKeysFrom(e)...)
	{{- else}}
	return ddbsdk.NewUnsafePut(idx.Table, idx.PrimaryKeyFrom(e), e)
	{{- end}}
}
{{if $idx.IsVersioned}}
// SafePut creates a Put operation with optimistic locking.
func (idx {{$idx.Name}}IndexUtil) SafePut(e *{{$idx.EntityType}}) *ddbsdk.PutWithCondition {
	{{- if $idx.GSIs}}
	return ddbsdk.NewSafePut(idx.Table, idx.PrimaryKeyFrom(e), e).WithGSIKeys(idx.GSIKeysFrom(e)...)
	{{- else}}
	return ddbsdk.NewSafePut(idx.Table, idx.PrimaryKeyFrom(e), e)
	{{- end}}
}
{{end}}
{{end}}
// Delete creates a Delete operation.
func (idx {{$idx.Name}}IndexUtil) Delete({{allParams $idx}}) *ddbsdk.Delete {
	return ddbsdk.NewDelete(idx.Table, idx.PrimaryKey({{allArgs $idx}}))
}

// UnsafeUpdate creates an Update operation without optimistic locking.
func (idx {{$idx.Name}}IndexUtil) UnsafeUpdate({{allParams $idx}}) *ddbsdk.UnsafeUpdate {
	return ddbsdk.NewUnsafeUpdate(idx.Table, idx.PrimaryKey({{allArgs $idx}}))
}

{{range $gsi := $idx.GSIs}}
// {{$gsi.Name}}Key creates a key for querying the {{$gsi.Name}} GSI.
func (idx {{$idx.Name}}IndexUtil) {{$gsi.Name}}Key({{gsiAllParams $gsi}}) table.PrimaryKey {
	return table.PrimaryKey{
		Definition: idx.Secondary[{{$gsi.Index}}].KeyDefinition(),
		Values: table.PrimaryKeyValues{
			PartitionKey: {{$gsi.PartitionKey.FormatExpr}},
			{{- if $gsi.HasSortKey}}
			SortKey:      {{$gsi.SortKey.FormatExpr}},
			{{- end}}
		},
	}
}
{{end}}

// -------------------------------------------------------------------------
// Primary Index Query Builder
// -------------------------------------------------------------------------

// {{$idx.Name}}PrimaryQuery is a query builder for the primary index.
type {{$idx.Name}}PrimaryQuery struct {
	idx *{{$idx.Name}}IndexUtil
	qd  ddbsdk.QueryDef
}

// Build returns the underlying QueryDef, implementing ddbsdk.QueryBuilder.
func (q {{$idx.Name}}PrimaryQuery) Build() ddbsdk.QueryDef { return q.qd }

// QueryPartition creates a query for the given partition key on the primary index.
func (idx {{$idx.Name}}IndexUtil) QueryPartition({{pkParams $idx.PartitionKey}}) {{$idx.Name}}PrimaryQuery {
	return {{$idx.Name}}PrimaryQuery{
		idx: &idx,
		qd:  ddbsdk.QueryPartition(idx.Table, {{$idx.PartitionKey.FormatExpr}}),
	}
}
{{if and $idx.HasSortKey (not $idx.SortKey.IsConstant)}}
// {{skPrefix $idx.SortKey}}Equals adds a sort key equals condition and returns the final QueryDef.
func (q {{$idx.Name}}PrimaryQuery) {{skPrefix $idx.SortKey}}Equals({{skEqualsParams $idx.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.Equals({{skEqualsFormatExpr $idx.SortKey}}))
}

// {{skPrefix $idx.SortKey}}BeginsWith adds a sort key begins_with condition and returns the final QueryDef.
func (q {{$idx.Name}}PrimaryQuery) {{skPrefix $idx.SortKey}}BeginsWith({{skBeginsWithParams $idx.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.BeginsWith({{skBeginsWithExpr $idx.SortKey}}))
}

// {{skPrefix $idx.SortKey}}Between adds a sort key between condition and returns the final QueryDef.
func (q {{$idx.Name}}PrimaryQuery) {{skPrefix $idx.SortKey}}Between({{skBetweenParams $idx.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.Between({{skBetweenStartExpr $idx.SortKey}}, {{skBetweenEndExpr $idx.SortKey}}))
}

// {{skPrefix $idx.SortKey}}GreaterThan adds a sort key > condition and returns the final QueryDef.
func (q {{$idx.Name}}PrimaryQuery) {{skPrefix $idx.SortKey}}GreaterThan({{skSingleValueParams $idx.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.GreaterThan({{skBoundExpr $idx.SortKey}}))
}

// {{skPrefix $idx.SortKey}}GreaterThanOrEqual adds a sort key >= condition and returns the final QueryDef.
func (q {{$idx.Name}}PrimaryQuery) {{skPrefix $idx.SortKey}}GreaterThanOrEqual({{skSingleValueParams $idx.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.GreaterThanOrEqual({{skBoundExpr $idx.SortKey}}))
}

// {{skPrefix $idx.SortKey}}LessThan adds a sort key < condition and returns the final QueryDef.
func (q {{$idx.Name}}PrimaryQuery) {{skPrefix $idx.SortKey}}LessThan({{skSingleValueParams $idx.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.LessThan({{skBoundExpr $idx.SortKey}}))
}

// {{skPrefix $idx.SortKey}}LessThanOrEqual adds a sort key <= condition and returns the final QueryDef.
func (q {{$idx.Name}}PrimaryQuery) {{skPrefix $idx.SortKey}}LessThanOrEqual({{skSingleValueParams $idx.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.LessThanOrEqual({{skBoundExpr $idx.SortKey}}))
}
{{end}}
{{range $gsi := $idx.GSIs}}
// -------------------------------------------------------------------------
// {{$idx.Name}}Index{{$gsi.Name}} - Query-only GSI Wrapper
// -------------------------------------------------------------------------

// {{$idx.Name}}Index{{$gsi.Name}}Util provides query methods for the {{$gsi.Name}} GSI.
type {{$idx.Name}}Index{{$gsi.Name}}Util struct {
	primary *{{$idx.Name}}IndexUtil
}

// {{$idx.Name}}Index{{$gsi.Name}} is the query-only wrapper for the {{$gsi.Name}} GSI.
var {{$idx.Name}}Index{{$gsi.Name}} = {{$idx.Name}}Index{{$gsi.Name}}Util{primary: &{{$idx.Name}}Index}

// {{$idx.Name}}{{$gsi.Name}}Query is a query builder for the {{$gsi.Name}} GSI.
type {{$idx.Name}}{{$gsi.Name}}Query struct {
	idx *{{$idx.Name}}Index{{$gsi.Name}}Util
	qd  ddbsdk.QueryDef
}

// QueryDef returns the underlying QueryDef, implementing ddbsdk.QueryDefinition.
func (q {{$idx.Name}}{{$gsi.Name}}Query) QueryDef() ddbsdk.QueryDef { return q.qd }

// QueryPartition creates a query for the given partition key on the {{$gsi.Name}} GSI.
func (idx {{$idx.Name}}Index{{$gsi.Name}}Util) QueryPartition({{pkParams $gsi.PartitionKey}}) {{$idx.Name}}{{$gsi.Name}}Query {
	return {{$idx.Name}}{{$gsi.Name}}Query{
		idx: &idx,
		qd:  ddbsdk.QueryPartition(idx.primary.Table, {{$gsi.PartitionKey.FormatExpr}}).OnIndex("{{$gsi.Name}}"),
	}
}
{{if and $gsi.HasSortKey (not $gsi.SortKey.IsConstant)}}
// {{skPrefix $gsi.SortKey}}Equals adds a sort key equals condition and returns the final QueryDef.
func (q {{$idx.Name}}{{$gsi.Name}}Query) {{skPrefix $gsi.SortKey}}Equals({{skEqualsParams $gsi.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.Equals({{skEqualsFormatExpr $gsi.SortKey}}))
}

// {{skPrefix $gsi.SortKey}}BeginsWith adds a sort key begins_with condition and returns the final QueryDef.
func (q {{$idx.Name}}{{$gsi.Name}}Query) {{skPrefix $gsi.SortKey}}BeginsWith({{skBeginsWithParams $gsi.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.BeginsWith({{skBeginsWithExpr $gsi.SortKey}}))
}

// {{skPrefix $gsi.SortKey}}Between adds a sort key between condition and returns the final QueryDef.
func (q {{$idx.Name}}{{$gsi.Name}}Query) {{skPrefix $gsi.SortKey}}Between({{skBetweenParams $gsi.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.Between({{skBetweenStartExpr $gsi.SortKey}}, {{skBetweenEndExpr $gsi.SortKey}}))
}

// {{skPrefix $gsi.SortKey}}GreaterThan adds a sort key > condition and returns the final QueryDef.
func (q {{$idx.Name}}{{$gsi.Name}}Query) {{skPrefix $gsi.SortKey}}GreaterThan({{skSingleValueParams $gsi.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.GreaterThan({{skBoundExpr $gsi.SortKey}}))
}

// {{skPrefix $gsi.SortKey}}GreaterThanOrEqual adds a sort key >= condition and returns the final QueryDef.
func (q {{$idx.Name}}{{$gsi.Name}}Query) {{skPrefix $gsi.SortKey}}GreaterThanOrEqual({{skSingleValueParams $gsi.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.GreaterThanOrEqual({{skBoundExpr $gsi.SortKey}}))
}

// {{skPrefix $gsi.SortKey}}LessThan adds a sort key < condition and returns the final QueryDef.
func (q {{$idx.Name}}{{$gsi.Name}}Query) {{skPrefix $gsi.SortKey}}LessThan({{skSingleValueParams $gsi.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.LessThan({{skBoundExpr $gsi.SortKey}}))
}

// {{skPrefix $gsi.SortKey}}LessThanOrEqual adds a sort key <= condition and returns the final QueryDef.
func (q {{$idx.Name}}{{$gsi.Name}}Query) {{skPrefix $gsi.SortKey}}LessThanOrEqual({{skSingleValueParams $gsi.SortKey}}) ddbsdk.QueryDef {
	return q.qd.WithSKCondition(ddbsdk.LessThanOrEqual({{skBoundExpr $gsi.SortKey}}))
}
{{end}}
{{end}}
{{end}}
` + "`" + `

// =============================================================================
// Schema generation
// =============================================================================

type schemaTable struct {
	Name         string        ` + "`yaml:\"name\"`" + `
	PartitionKey schemaKeyDef  ` + "`yaml:\"partitionKey\"`" + `
	SortKey      *schemaKeyDef ` + "`yaml:\"sortKey,omitempty\"`" + `
	GSIs         []schemaGSI   ` + "`yaml:\"gsis,omitempty\"`" + `
	Entities     []schemaEntity ` + "`yaml:\"entities,omitempty\"`" + `
}

type schemaKeyDef struct {
	Name string ` + "`yaml:\"name\"`" + `
	Kind string ` + "`yaml:\"kind\"`" + `
}

type schemaGSI struct {
	Name         string        ` + "`yaml:\"name\"`" + `
	PartitionKey schemaKeyDef  ` + "`yaml:\"partitionKey\"`" + `
	SortKey      *schemaKeyDef ` + "`yaml:\"sortKey,omitempty\"`" + `
}

type schemaEntity struct {
	Type                string          ` + "`yaml:\"type\"`" + `
	PartitionKeyPattern string          ` + "`yaml:\"partitionKeyPattern\"`" + `
	SortKeyPattern      string          ` + "`yaml:\"sortKeyPattern,omitempty\"`" + `
	Fields              []schemaField   ` + "`yaml:\"fields\"`" + `
	GSIMappings         []schemaGSIMap  ` + "`yaml:\"gsiMappings,omitempty\"`" + `
	IsVersioned         bool            ` + "`yaml:\"isVersioned,omitempty\"`" + `
}

type schemaField struct {
	Name string ` + "`yaml:\"name\"`" + `
	Tag  string ` + "`yaml:\"tag\"`" + `
	Type string ` + "`yaml:\"type\"`" + `
}

type schemaGSIMap struct {
	GSI              string ` + "`yaml:\"gsi\"`" + `
	PartitionPattern string ` + "`yaml:\"partitionPattern\"`" + `
	SortPattern      string ` + "`yaml:\"sortPattern,omitempty\"`" + `
}

type schemaRoot struct {
	Tables []schemaTable ` + "`yaml:\"tables\"`" + `
}

func generateSchemaFiles(schemaDir string, indexes []indexInfo) error {
	// Group indexes by table, preserving discovery order
	tableIndexes := make(map[string][]indexInfo)
	var tableOrder []string
	for _, idx := range indexes {
		tableName := idx.TableName
		if tableName == "" {
			tableName = idx.EntityType
		}
		if _, exists := tableIndexes[tableName]; !exists {
			tableOrder = append(tableOrder, tableName)
		}
		tableIndexes[tableName] = append(tableIndexes[tableName], idx)
	}

	var tables []schemaTable
	for _, tableName := range tableOrder {
		idxs := tableIndexes[tableName]
		firstIdx := idxs[0]
		tbl := schemaTable{
			Name: tableName,
			PartitionKey: schemaKeyDef{Name: firstIdx.PKDefName, Kind: firstIdx.PartitionKey.Kind},
		}
		if firstIdx.SortKey.Pattern != "" {
			tbl.SortKey = &schemaKeyDef{Name: firstIdx.SKDefName, Kind: firstIdx.SortKey.Kind}
		}
		for _, gsi := range firstIdx.GSIs {
			g := schemaGSI{
				Name:         gsi.Name,
				PartitionKey: schemaKeyDef{Name: gsi.PKDef, Kind: gsi.PKPattern.Kind},
			}
			if gsi.SKPattern.Pattern != "" {
				g.SortKey = &schemaKeyDef{Name: gsi.SKDef, Kind: gsi.SKPattern.Kind}
			}
			tbl.GSIs = append(tbl.GSIs, g)
		}
		for _, idx := range idxs {
			entity := schemaEntity{
				Type:                idx.EntityType,
				PartitionKeyPattern: idx.PartitionKey.Pattern,
				IsVersioned:         idx.IsVersioned,
			}
			if idx.SortKey.Pattern != "" {
				entity.SortKeyPattern = idx.SortKey.Pattern
			}
			for _, f := range idx.Fields {
				entity.Fields = append(entity.Fields, schemaField{Name: f.Name, Tag: f.Tag, Type: f.Type})
			}
			for _, gsi := range idx.GSIs {
				mapping := schemaGSIMap{GSI: gsi.Name, PartitionPattern: gsi.PKPattern.Pattern}
				if gsi.SKPattern.Pattern != "" {
					mapping.SortPattern = gsi.SKPattern.Pattern
				}
				entity.GSIMappings = append(entity.GSIMappings, mapping)
			}
			tbl.Entities = append(tbl.Entities, entity)
		}
		tables = append(tables, tbl)
	}

	schema := schemaRoot{Tables: tables}

	var buf bytes.Buffer
	encoder := yaml.NewEncoder(&buf)
	encoder.SetIndent(1)
	if err := encoder.Encode(schema); err != nil {
		return fmt.Errorf("marshaling schema: %w", err)
	}
	encoder.Close()

	header := []byte("# Generated by ddbgen. DO NOT EDIT.\n\n")
	data := append(header, buf.Bytes()...)

	yamlPath := filepath.Join(schemaDir, "schema_dynamodb.yaml")
	if err := os.WriteFile(yamlPath, data, 0644); err != nil {
		return fmt.Errorf("writing schema file: %w", err)
	}
	fmt.Printf("ddb gen: generated %s (%d tables)\n", yamlPath, len(tables))

	schemaGoCode := ` + "`" + `// Code generated by ddbgen. DO NOT EDIT.

package schema

import (
	_ "embed"

	"github.com/acksell/bezos/dynamodb/schema"
	"gopkg.in/yaml.v3"
)

//go:embed schema_dynamodb.yaml
var schemaYAML []byte

// Schema contains the DynamoDB table and entity definitions for this package.
// Pass this to ddbui.NewServer to enable schema-aware debugging UI.
var Schema schema.Schema

func init() {
	if err := yaml.Unmarshal(schemaYAML, &Schema); err != nil {
		panic("ddbgen: failed to parse embedded schema: " + err.Error())
	}
}
` + "`" + `

	schemaGoPath := filepath.Join(schemaDir, "schema_gen.go")
	if err := os.WriteFile(schemaGoPath, []byte(schemaGoCode), 0644); err != nil {
		return fmt.Errorf("writing schema go file: %w", err)
	}
	fmt.Printf("ddb gen: generated %s\n", schemaGoPath)

	return nil
}

// Suppress unused import warnings in the sidecar
var _ = yaml.Marshal
var _ = base64.StdEncoding
var _ = regexp.MustCompile
var _ = format.Source
`
