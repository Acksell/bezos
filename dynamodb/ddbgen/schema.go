package ddbgen

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/acksell/bezos/dynamodb/schema"
	"gopkg.in/yaml.v3"
)

// GenerateSchemas converts a DiscoverResult into a Schema.
// Returns a schema.Schema containing all tables and entities.
func GenerateSchemas(result *DiscoverResult) (schema.Schema, error) {
	if len(result.Indexes) == 0 {
		return schema.Schema{}, fmt.Errorf("no indexes to generate schemas for")
	}

	// Group indexes by table name
	tableIndexes := make(map[string][]IndexInfo)
	tableSchemas := make(map[string]*schema.Table)

	for _, idx := range result.Indexes {
		tableName := idx.TableName
		if tableName == "" {
			// Fallback: use entity type as table identifier
			tableName = idx.EntityType
		}
		tableIndexes[tableName] = append(tableIndexes[tableName], idx)
	}

	for tableName, indexes := range tableIndexes {
		// Use the first index to get table structure (all should share same table)
		firstIdx := indexes[0]

		tbl := &schema.Table{
			Name: tableName,
			PartitionKey: schema.KeyDef{
				Name: firstIdx.PKDefName,
				Kind: string(firstIdx.PartitionKey.Kind),
			},
			Entities: make([]schema.Entity, 0, len(indexes)),
		}

		// Add sort key if present
		if firstIdx.SortKey.Pattern != "" {
			tbl.SortKey = &schema.KeyDef{
				Name: firstIdx.SKDefName,
				Kind: string(firstIdx.SortKey.Kind),
			}
		}

		// Add GSIs from the first index (table structure)
		for _, gsi := range firstIdx.GSIs {
			gsiSchema := schema.GSI{
				Name: gsi.Name,
				PartitionKey: schema.KeyDef{
					Name: gsi.PKDef,
					Kind: string(gsi.PKPattern.Kind),
				},
			}
			if gsi.SKPattern.Pattern != "" {
				gsiSchema.SortKey = &schema.KeyDef{
					Name: gsi.SKDef,
					Kind: string(gsi.SKPattern.Kind),
				}
			}
			tbl.GSIs = append(tbl.GSIs, gsiSchema)
		}

		// Add entity schemas
		for _, idx := range indexes {
			entity := schema.Entity{
				Type:                idx.EntityType,
				PartitionKeyPattern: idx.PartitionKey.Pattern,
				IsVersioned:         idx.IsVersioned,
			}

			if idx.SortKey.Pattern != "" {
				entity.SortKeyPattern = idx.SortKey.Pattern
			}

			// Add fields from discovery result
			if fields, ok := result.EntityFields[idx.EntityType]; ok {
				for _, f := range fields {
					entity.Fields = append(entity.Fields, schema.Field{
						Name: f.Name,
						Tag:  f.Tag,
						Type: f.Type,
					})
				}
			}

			// Add GSI mappings
			for _, gsi := range idx.GSIs {
				mapping := schema.GSIMapping{
					GSI:              gsi.Name,
					PartitionPattern: gsi.PKPattern.Pattern,
				}
				if gsi.SKPattern.Pattern != "" {
					mapping.SortPattern = gsi.SKPattern.Pattern
				}
				entity.GSIMappings = append(entity.GSIMappings, mapping)
			}

			tbl.Entities = append(tbl.Entities, entity)
		}

		tableSchemas[tableName] = tbl
	}

	// Convert map to slice
	var tables []schema.Table
	for _, tbl := range tableSchemas {
		tables = append(tables, *tbl)
	}

	return schema.Schema{Tables: tables}, nil
}

// WriteSchemas writes all schemas to a single schema_dynamodb.yaml file.
func WriteSchemas(s schema.Schema, dir string) error {
	path := filepath.Join(dir, "schema_dynamodb.yaml")

	var buf bytes.Buffer
	encoder := yaml.NewEncoder(&buf)
	encoder.SetIndent(1)
	if err := encoder.Encode(s); err != nil {
		return fmt.Errorf("marshaling schemas: %w", err)
	}
	encoder.Close()

	// Add header comment
	header := []byte("# Generated by ddbgen. DO NOT EDIT.\n\n")
	data := append(header, buf.Bytes()...)

	if err := os.WriteFile(path, data, 0644); err != nil {
		return fmt.Errorf("writing schema file: %w", err)
	}
	return nil
}
