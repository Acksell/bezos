package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const genMainHeader = "// Code generated by ddbgen. DO NOT EDIT."

// genMainTemplate is the template for the bootstrapped gen/main.go file.
var genMainTemplate = template.Must(template.New("gen_main").Parse(`// Code generated by ddbgen. DO NOT EDIT.
package main

import (
	"fmt"
	"os"

	_ "{{.PkgPath}}" // registers indexes via indices.Add

	"github.com/acksell/bezos/dynamodb/ddbgen"
)

func main() {
	if err := ddbgen.Generate(ddbgen.GenerateOptions{
		Dir:         ".",
		PackageName: "{{.PkgName}}",
	}); err != nil {
		fmt.Fprintf(os.Stderr, "ddbgen: %v\n", err)
		os.Exit(1)
	}
}
`))

func runGen() error {
	fs := flag.NewFlagSet("gen", flag.ExitOnError)

	fs.Usage = func() {
		fmt.Println(`ddb gen - Generate type-safe key constructors and schema files

Usage:
  ddb gen [flags]

When invoked via go:generate (i.e. //go:generate ddb gen):
  - Creates gen/main.go if it doesn't exist (bootstraps the generator)
  - Runs go run ./gen to generate index_gen.go and schema/ files

When invoked from the CLI:
  - Discovers all gen/main.go files created by ddbgen in the repo
  - Runs each one to regenerate code

Examples:
  # Add to your indexes.go:
  //go:generate ddb gen

  # Generate all packages:
  go generate ./...

  # Or run directly:
  ddb gen`)
	}

	if err := fs.Parse(os.Args[1:]); err != nil {
		return err
	}

	// Detect if we're running inside go:generate by checking env vars.
	goPackage := os.Getenv("GOPACKAGE")
	if goPackage != "" {
		return runGenFromGoGenerate(goPackage)
	}

	return runGenFromCLI()
}

// runGenFromGoGenerate is called when `ddb gen` is invoked via //go:generate.
// It bootstraps gen/main.go if needed, then runs it.
func runGenFromGoGenerate(pkgName string) error {
	// Determine the package import path.
	pkgPath, err := getPackageImportPath(".")
	if err != nil {
		return fmt.Errorf("determining package import path: %w", err)
	}

	// Create gen/main.go if it doesn't exist.
	genDir := "gen"
	genMain := filepath.Join(genDir, "main.go")

	if _, err := os.Stat(genMain); os.IsNotExist(err) {
		if err := os.MkdirAll(genDir, 0755); err != nil {
			return fmt.Errorf("creating gen directory: %w", err)
		}

		var buf bytes.Buffer
		if err := genMainTemplate.Execute(&buf, struct {
			PkgPath string
			PkgName string
		}{
			PkgPath: pkgPath,
			PkgName: pkgName,
		}); err != nil {
			return fmt.Errorf("executing gen/main.go template: %w", err)
		}

		if err := os.WriteFile(genMain, buf.Bytes(), 0644); err != nil {
			return fmt.Errorf("writing gen/main.go: %w", err)
		}
		fmt.Printf("ddb gen: created %s\n", genMain)
	}

	// Run gen/main.go.
	fmt.Printf("ddb gen: running go run ./gen\n")
	cmd := exec.Command("go", "run", "./gen")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("running gen/main.go: %w", err)
	}

	return nil
}

// runGenFromCLI is called when `ddb gen` is invoked directly from the command line.
// It discovers all gen/main.go files in the repo and runs them.
func runGenFromCLI() error {
	genFiles, err := discoverGenFiles()
	if err != nil {
		return fmt.Errorf("discovering gen files: %w", err)
	}

	if len(genFiles) == 0 {
		return fmt.Errorf(`no gen/main.go files found

To set up code generation:

  1. Register your indexes using indices.Add in your indexes file:

       var _ = indices.Add(index.PrimaryIndex[MyEntity]{...})

  2. Add this directive to the same file:

       //go:generate ddb gen

  3. Run:

       go generate ./...`)
	}

	fmt.Printf("ddb gen: found %d gen file(s)\n", len(genFiles))

	var errs []string
	for _, genFile := range genFiles {
		// Run from the parent directory of gen/main.go (i.e., the user's package dir).
		genDir := filepath.Dir(genFile)
		pkgDir := filepath.Dir(genDir)

		fmt.Printf("ddb gen: running %s\n", genFile)
		cmd := exec.Command("go", "run", "./gen")
		cmd.Dir = pkgDir
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			errs = append(errs, fmt.Sprintf("%s: %v", genFile, err))
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("errors running gen files:\n  %s", strings.Join(errs, "\n  "))
	}

	return nil
}

// getPackageImportPath returns the import path of the Go package in dir.
func getPackageImportPath(dir string) (string, error) {
	cmd := exec.Command("go", "list", ".")
	cmd.Dir = dir
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}

// discoverGenFiles finds all gen/main.go files that were created by ddbgen.
// It uses git ls-files when available, falling back to a directory walk.
func discoverGenFiles() ([]string, error) {
	// Try git ls-files first.
	if files, err := discoverGenFilesWithGit(); err == nil && len(files) > 0 {
		return files, nil
	}

	// Fallback to directory walk.
	return discoverGenFilesWithWalk()
}

// discoverGenFilesWithGit uses git ls-files to find gen/main.go files.
func discoverGenFilesWithGit() ([]string, error) {
	if _, err := exec.LookPath("git"); err != nil {
		return nil, err
	}

	cmd := exec.Command("git", "ls-files", "--cached", "--others", "--exclude-standard")
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	var files []string
	scanner := bufio.NewScanner(bytes.NewReader(output))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasSuffix(line, "gen/main.go") {
			abs, err := filepath.Abs(line)
			if err != nil {
				abs = line
			}
			if isDdbgenGenFile(abs) {
				files = append(files, abs)
			}
		}
	}

	return files, scanner.Err()
}

// discoverGenFilesWithWalk walks the directory tree to find gen/main.go files.
func discoverGenFilesWithWalk() ([]string, error) {
	var files []string

	skipDirs := map[string]bool{
		".git": true, "node_modules": true, "vendor": true,
		".ddb": true, "__pycache__": true, ".venv": true,
	}

	err := filepath.WalkDir(".", func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return nil
		}
		if d.IsDir() {
			if skipDirs[d.Name()] {
				return filepath.SkipDir
			}
			return nil
		}
		if d.Name() == "main.go" && strings.HasSuffix(filepath.Dir(path), "gen") {
			abs, err := filepath.Abs(path)
			if err != nil {
				abs = path
			}
			if isDdbgenGenFile(abs) {
				files = append(files, abs)
			}
		}
		return nil
	})

	return files, err
}

// isDdbgenGenFile checks if a file was generated by ddbgen by reading
// its first line for the auto-generated header.
func isDdbgenGenFile(path string) bool {
	f, err := os.Open(path)
	if err != nil {
		return false
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	if scanner.Scan() {
		return strings.Contains(scanner.Text(), "Code generated by ddbgen")
	}
	return false
}
